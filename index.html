<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Math Bomb ¬∑ Online Zamanlƒ± Matematik Oyunu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --card: #0f172a;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.2);
      --danger: #f97373;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --radius: 16px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #0b1120, #020617 55%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      overflow-y: auto;
    }

    .app {
      max-width: 960px;
      width: 100%;
      padding: 24px 16px 32px;
    }

    .card {
      position: relative;
      background: radial-gradient(circle at top, #020617, #020617 40%), var(--card);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.4);
      backdrop-filter: blur(24px);
      overflow: hidden;
    }

    .card > * { position: relative; z-index: 1; }

    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: var(--radius);
      background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 35%),
                  radial-gradient(circle at 80% 0%, rgba(34, 197, 94, 0.08), transparent 30%);
      pointer-events: none;
      opacity: 0.6;
      animation: panelGlow 10s ease-in-out infinite;
      z-index: 0;
    }

    h1 {
      margin-top: 0;
      font-size: 2rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.icon { font-size: 2.2rem; }

    .subtitle {
      color: var(--text-soft);
      margin-bottom: 12px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 16px;
    }

    .col {
      flex: 1 1 260px;
    }

    label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    input, select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
    }

    input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(to right, #22c55e, #38bdf8);
      color: #0f172a;
      box-shadow: 0 8px 25px rgba(56, 189, 248, 0.45);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    button.secondary {
      background: transparent;
      border: 1px solid #4b5563;
      color: var(--text-soft);
      box-shadow: none;
    }

    button[disabled] {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    }

    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      margin-bottom: 8px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid rgba(75, 85, 99, 0.7);
      color: var(--text-soft);
    }

    .pill-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.7);
    }

    .players {
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.95);
      padding: 10px 12px;
      max-height: 220px;
      overflow-y: auto;
      font-size: 0.85rem;
    }

    .player-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(31, 41, 55, 0.7);
    }

    .player-row:last-child { border-bottom: none; }

    .player-name {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .player-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
    }

    .player-dot.dead { background: #4b5563; }

    .player-tag {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: #9ca3af;
    }

    .bot-controls {
      margin-top: 12px;
      border: 1px dashed rgba(56, 189, 248, 0.5);
      border-radius: 10px;
      padding: 10px;
      background: rgba(15, 23, 42, 0.6);
    }

    .bot-controls h4 {
      margin: 0 0 6px 0;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bot-controls .bot-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
    }

    .bot-controls .bot-hint {
      font-size: 0.75rem;
      color: var(--text-soft);
      margin: 0;
    }

    .status-banner {
      margin-top: 16px;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: radial-gradient(circle at left, rgba(56, 189, 248, 0.12), transparent),
                  rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(75, 85, 99, 0.8);
    }

    .status-text strong { color: var(--accent); }

    .status-danger {
      color: var(--danger);
      font-weight: 600;
    }

    /* Bomb & timer area */
    .bomb-panel {
      margin-top: 18px;
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), #020617);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(2, 6, 23, 0.8);
    }

    .bomb-panel::before {
      content: "";
      position: absolute;
      inset: -20%;
      background: radial-gradient(circle at 30% 30%, rgba(56, 189, 248, 0.12), transparent 35%),
                  radial-gradient(circle at 70% 70%, rgba(250, 204, 21, 0.08), transparent 40%);
      filter: blur(30px);
      animation: panelShimmer 14s linear infinite;
      pointer-events: none;
    }

    .bomb-wrapper {
      position: relative;
      width: 160px;
      height: 160px;
    }

    .bomb {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      margin: 0 auto;
      background: radial-gradient(circle at 30% 30%, #1f2937, #020617 70%);
      box-shadow: 0 16px 40px rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      animation: bombFloat 4s ease-in-out infinite;
    }

    .bomb.ticking {
      box-shadow: 0 0 24px rgba(56, 189, 248, 0.7);
      animation: bombPulse 1.2s ease-in-out infinite, bombFloat 3s ease-in-out infinite;
    }

    .bomb.exploding {
      background: radial-gradient(circle at 30% 30%, #b91c1c, #020617 80%);
      box-shadow: 0 0 60px rgba(248, 113, 113, 0.95);
      transform: translate(-50%, -50%) scale(1.05);
      animation: bombShake 0.35s linear infinite;
    }

    .bomb.critical {
      animation: bombPulse 0.6s ease-in-out infinite, bombShake 0.4s linear infinite;
      background: radial-gradient(circle at 40% 30%, #1f2937, #111827 70%);
    }

    .bomb-timer {
      font-size: 2rem;
      font-weight: 700;
      color: #f9fafb;
      text-shadow: 0 0 10px rgba(248, 113, 113, 0.4);
      transition: transform 0.2s ease, text-shadow 0.2s ease;
    }

    .bomb-timer.flash {
      transform: scale(1.12);
      text-shadow: 0 0 16px rgba(248, 113, 113, 0.7);
    }

    .fuse {
      position: absolute;
      width: 80px;
      height: 4px;
      border-radius: 999px;
      background: #facc15;
      top: 10px;
      left: 50%;
      transform-origin: left center;
      transform: translateX(-10%) rotate(-20deg);
      box-shadow: 0 0 10px rgba(250, 204, 21, 0.7);
      animation: fusePulse 1.8s ease-in-out infinite;
    }

    .spark {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: radial-gradient(circle, #f97316, rgba(248, 113, 113, 0));
      top: 4px;
      right: -6px;
      animation: spark 0.3s infinite alternate;
      pointer-events: none;
    }

    @keyframes spark {
      from { transform: scale(0.7); opacity: 0.7; }
      to   { transform: scale(1.1); opacity: 1; }
    }

    @keyframes bombFloat {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-6px); }
    }

    @keyframes bombPulse {
      0%, 100% { box-shadow: 0 0 24px rgba(56, 189, 248, 0.5); }
      50% { box-shadow: 0 0 32px rgba(248, 113, 113, 0.8); }
    }

    @keyframes bombShake {
      0%, 100% { transform: translate(-50%, -50%) translateX(0); }
      25% { transform: translate(-50%, -50%) translateX(-2px); }
      50% { transform: translate(-50%, -50%) translateX(2px); }
      75% { transform: translate(-50%, -50%) translateX(-3px); }
    }

    @keyframes fusePulse {
      0%, 100% { opacity: 0.8; box-shadow: 0 0 10px rgba(250, 204, 21, 0.6); }
      50% { opacity: 1; box-shadow: 0 0 18px rgba(250, 204, 21, 0.9); }
    }

    @keyframes panelShimmer {
      0% { transform: rotate(0deg) scale(1); opacity: 0.7; }
      50% { transform: rotate(180deg) scale(1.05); opacity: 1; }
      100% { transform: rotate(360deg) scale(1); opacity: 0.7; }
    }

    @keyframes panelGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 0.9; }
    }

    .question {
      font-size: 1.3rem;
      font-weight: 600;
      text-align: center;
      margin-top: 4px;
    }

    .answer-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      align-items: center;
      margin-top: 8px;
    }

    .small-input {
      width: 110px;
      text-align: center;
    }

    .pass-select {
      min-width: 160px;
    }

    .log {
      margin-top: 12px;
      font-size: 0.8rem;
      color: var(--text-soft);
      max-height: 120px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .log-line { margin-bottom: 4px; }

    .error {
      color: var(--danger);
      font-size: 0.8rem;
      margin-top: 6px;
    }

    .scoreboard {
      margin-top: 12px;
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      padding: 10px 12px;
      font-size: 0.8rem;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(31,41,55,0.7);
    }

    .score-row:last-child { border-bottom: none; }

    .score-points { font-weight: 600; }

    #status-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-end;
      align-items: center;
    }

    .lang-switch {
      position: absolute;
      right: 12px;
      top: 12px;
      display: flex;
      gap: 6px;
    }

    .lang-btn {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.8);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      cursor: pointer;
    }

    .lang-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.4);
    }

    @media (max-width: 768px) {
      .card { padding: 16px; }
      .bomb-wrapper { width: 140px; height: 140px; }
      .bomb { width: 120px; height: 120px; }
      .bomb-timer { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="card">
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="tr">üáπüá∑ TR</button>
      <button class="lang-btn" data-lang="en">üá¨üáß EN</button>
    </div>

    <h1>
      <span class="icon">üí£</span>
      <span id="title-text">Math Bomb</span>
    </h1>
    <div class="subtitle" id="subtitle-text">
      Basit i≈ülemler, kƒ±sƒ±tlƒ± s√ºre, elinde patlamadan doƒüru cevabƒ± bul ve bombayƒ± birine at.
    </div>

    <!-- Setup -->
    <div class="row" id="setup-section">
      <div class="col">
        <div class="section-title" id="create-section-title">Yeni Oyun Olu≈ütur</div>
        <label id="label-creator-name">ƒ∞smin</label>
        <input id="creator-name" placeholder="Umut, Nova vs." />

        <label style="margin-top:8px;" id="label-time-limit">S√ºre (saniye)</label>
        <select id="time-limit">
          <option value="20">20</option>
          <option value="30" selected>30</option>
          <option value="45">45</option>
          <option value="60">60</option>
        </select>

        <label style="margin-top:8px;" id="label-difficulty">Zorluk</label>
        <select id="difficulty-level">
          <option value="normal" selected>Normal</option>
          <option value="hard">Zor</option>
          <option value="very_hard">√áok Zor</option>
        </select>

        <button id="create-game-btn" style="margin-top:12px;">
          <span id="btn-create-text">Oyun Olu≈ütur</span> <span>‚ûï</span>
        </button>
        <div id="create-error" class="error"></div>
      </div>

      <div class="col">
        <div class="section-title" id="join-section-title">Koda / Linke G√∂re Katƒ±l</div>
        <label id="label-join-name">ƒ∞smin</label>
        <input id="join-name" placeholder="ƒ∞smin" />

        <label style="margin-top:8px;" id="label-join-code">Oda Kodu</label>
        <input id="join-code" placeholder="√ñrn: ABCD12" />

        <button id="join-game-btn" style="margin-top:12px;" class="secondary">
          <span id="btn-join-text">Oyuna Katƒ±l</span> <span>‚û°Ô∏è</span>
        </button>
        <div id="join-help-text" style="margin-top:8px;font-size:0.8rem;color:var(--text-soft);">
          Eƒüer linkle geldiysen kod otomatik dolabilir.
        </div>
        <div id="join-error" class="error"></div>
      </div>
    </div>

    <!-- Game -->
    <div id="game-section" style="display:none; margin-top:16px;">
      <div class="row">
        <div class="col">
          <div class="section-title" id="room-section-title">Oda</div>
          <div class="pill">
            <span class="pill-dot"></span>
            <span id="room-status-text">Bekleniyor...</span>
          </div>
          <div style="margin-top:8px;font-size:0.85rem;">
            <span id="room-code-label">Oda kodu:</span>
            <strong id="room-code">-</strong>
          </div>
          <div style="margin-top:4px;font-size:0.8rem;">
            <span id="room-link-label">Link:</span>
            <a id="room-link" class="link" href="#" style="color:var(--accent);word-break:break-all;"></a>
          </div>
          <div style="margin-top:4px;font-size:0.8rem;">
            <span id="room-difficulty-label">Zorluk:</span>
            <strong id="room-difficulty">-</strong>
          </div>
        </div>
        <div class="col">
          <div class="section-title" id="players-section-title">Oyuncular</div>
          <div class="players" id="players-list"></div>
          <div class="bot-controls" id="bot-controls" style="display:none;">
            <h4>ü§ñ <span id="bot-section-title">Botlar</span></h4>
            <div class="bot-row">
              <input id="bot-count" class="small-input" type="number" min="1" max="6" value="1" />
              <button id="add-bot-btn">‚ûï <span id="add-bot-btn-text">Bot Ekle</span></button>
            </div>
            <p class="bot-hint" id="bot-helper-text">Botlar y√ºksek doƒürulukla otomatik cevap verir.</p>
          </div>
        </div>
      </div>

      <div class="status-banner">
        <div class="status-text" id="status-text">Oyun hen√ºz ba≈ülamadƒ±.</div>
        <div id="status-actions"></div>
      </div>

      <div class="bomb-panel">
        <div class="section-title" id="bomb-section-title">Bomba & Soru</div>

        <div class="bomb-wrapper">
          <div class="bomb" id="bomb">
            <div class="bomb-timer" id="bomb-timer">--</div>
          </div>
          <div class="fuse">
            <div class="spark"></div>
          </div>
        </div>

        <div class="question" id="question-text">Soru bekleniyor...</div>

        <div class="answer-row">
          <input id="answer-input" class="small-input" type="number" placeholder="Cevap" />
          <select id="pass-target" class="pass-select">
          </select>
          <button id="submit-answer-btn">
            <span id="btn-submit-text">Cevapla & Bombayƒ± At</span>
          </button>
        </div>

        <div class="log" id="log"></div>
      </div>

      <div class="scoreboard" id="scoreboard">
        <div class="section-title" id="scoreboard-title">Skor Tablosu</div>
        <div id="scoreboard-body"></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  // TODO: kendi Supabase proje bilgilerin
  const SUPABASE_URL = "https://tkggowekxmnlixwinszl.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRrZ2dvd2VreG1ubGl4d2luc3psIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3MzI1NjcsImV4cCI6MjA4MDMwODU2N30.y1GSvarl9YyBqMaP8x6SXeD88EJ10gjee4rlr6oLyZg";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const LS_KEY = "math_bomb_state_v1";
  const LS_LANG = "math_bomb_lang";

  // --- i18n ---
  let currentLang = localStorage.getItem(LS_LANG) || "tr";

  const textMap = {
    tr: {
      title: "Math Bomb",
      subtitle: "Basit i≈ülemler, kƒ±sƒ±tlƒ± s√ºre. Elinde patlamadan doƒüru cevabƒ± bul ve bombayƒ± birine at.",
      createSectionTitle: "Yeni Oyun Olu≈ütur",
      joinSectionTitle: "Koda / Linke G√∂re Katƒ±l",
      labelCreatorName: "ƒ∞smin",
      labelTimeLimit: "S√ºre (saniye)",
      labelDifficulty: "Zorluk",
      labelJoinName: "ƒ∞smin",
      labelJoinCode: "Oda Kodu",
      btnCreate: "Oyun Olu≈ütur",
      btnJoin: "Oyuna Katƒ±l",
      joinHelp: "Eƒüer linkle geldiysen kod otomatik dolabilir.",
      roomSectionTitle: "Oda",
      roomCodeLabel: "Oda kodu:",
      roomLinkLabel: "Link:",
      roomDifficultyLabel: "Zorluk:",
      playersSectionTitle: "Oyuncular",
      bombSectionTitle: "Bomba & Soru",
      statusWaiting: "Oyun hen√ºz ba≈ülamadƒ±. Oyuncular katƒ±labilir.",
      statusRunningPrefix: "Sƒ±ra:",
      statusFinished: "Oyun bitti.",
      labelScoreboard: "Skor Tablosu",
      botTag: "Bot",
      botSectionTitle: "Botlar",
      botHelper: "Botlar y√ºksek doƒürulukla otomatik cevap verir. Eklemeler ev sahibi tarafƒ±ndan yapƒ±lƒ±r.",
      addBotButton: "Bot Ekle",
      botLocked: "Oyun s√ºrerken bot eklenemez.",
      logBotsAdded: count => `${count} bot eklendi.`,
      logBotThinking: name => `${name} d√º≈ü√ºn√ºyor...`,
      logBotWrong: name => `${name} cevabƒ± ka√ßƒ±rdƒ±, tekrar deniyor.`,
      btnStartGame: "Oyunu Ba≈ülat",
      btnPlayAgain: "Tekrar Oyna (Aynƒ± Oda)",
      btnNewRoom: "Yeni Oda",
      btnSubmit: "Cevapla & Bombayƒ± At",
      errorNameRequired: "ƒ∞smini yazmalƒ±sƒ±n.",
      errorCodeRequired: "Oda kodu bo≈ü olamaz.",
      errorRoomNotFound: "B√∂yle bir oda bulunamadƒ±.",
      logGameCreated: slug => `Oyun olu≈üturuldu. Kod: ${slug}`,
      logJoined: slug => `Odaya katƒ±ldƒ±n. Kod: ${slug}`,
      logStart: name => `Oyun ba≈üladƒ±. ƒ∞lk oyuncu: ${name}`,
      logQuestion: q => `Yeni soru: ${q}`,
      logAnswerCorrect: (p, t) => `${p} doƒüru bildi ve bombayƒ± ${t}'ye attƒ±.`,
      logAnswerWrong: p => `${p} yanlƒ±≈ü cevap verdi, tekrar deneyebilir.`,
      logTimeout: p => `S√ºre bitti! Bomba ${p}'nin elinde patladƒ±.`,
      logReset: "Yeni tur i√ßin hazƒ±r. Oyuncular bekleniyor.",
      labelTimer: "Kalan s√ºre",
      youLabel: "Sen",
      deadTag: "Patladƒ±",
      hostTag: "Kurucu",
      statusTurnPreparing: "Sƒ±ra bilgisi y√ºkleniyor...",
      difficultyNormal: "Normal",
      difficultyHard: "Zor",
      difficultyVeryHard: "√áok Zor",
    },
    en: {
      title: "Math Bomb",
      subtitle: "Simple math, limited time. Solve before it blows up and pass the bomb to someone else.",
      createSectionTitle: "Create New Game",
      joinSectionTitle: "Join with Code / Link",
      labelCreatorName: "Your name",
      labelTimeLimit: "Time (seconds)",
      labelDifficulty: "Difficulty",
      labelJoinName: "Your name",
      labelJoinCode: "Room Code",
      btnCreate: "Create Game",
      btnJoin: "Join Game",
      joinHelp: "If you came via link, the code may auto-fill.",
      roomSectionTitle: "Room",
      roomCodeLabel: "Room code:",
      roomLinkLabel: "Link:",
      roomDifficultyLabel: "Difficulty:",
      playersSectionTitle: "Players",
      bombSectionTitle: "Bomb & Question",
      statusWaiting: "Game has not started yet. Players can still join.",
      statusRunningPrefix: "Turn:",
      statusFinished: "Game over.",
      labelScoreboard: "Scoreboard",
      botTag: "Bot",
      botSectionTitle: "Bots",
      botHelper: "Bots auto-answer with high accuracy. Only the host can add them.",
      addBotButton: "Add Bot",
      botLocked: "Bots cannot be added during an active round.",
      logBotsAdded: count => `${count} bot(s) added.`,
      logBotThinking: name => `${name} is thinking...`,
      logBotWrong: name => `${name} missed the answer, trying again.`,
      btnStartGame: "Start Game",
      btnPlayAgain: "Play Again (Same Room)",
      btnNewRoom: "New Room",
      btnSubmit: "Answer & Pass Bomb",
      errorNameRequired: "Please enter your name.",
      errorCodeRequired: "Room code cannot be empty.",
      errorRoomNotFound: "Room not found.",
      logGameCreated: slug => `Game created. Code: ${slug}`,
      logJoined: slug => `Joined room. Code: ${slug}`,
      logStart: name => `Game started. First player: ${name}`,
      logQuestion: q => `New question: ${q}`,
      logAnswerCorrect: (p, t) => `${p} answered correctly and passed the bomb to ${t}.`,
      logAnswerWrong: p => `${p} answered wrong, can try again while time remains.`,
      logTimeout: p => `Time is up! The bomb exploded in ${p}'s hands.`,
      logReset: "Ready for a new round. Waiting for players.",
      labelTimer: "Time left",
      youLabel: "You",
      deadTag: "Boom",
      hostTag: "Host",
      statusTurnPreparing: "Turn info loading...",
      difficultyNormal: "Normal",
      difficultyHard: "Hard",
      difficultyVeryHard: "Very Hard",
    }
  };

  function applyLanguage() {
    const t = textMap[currentLang];
    document.getElementById("title-text").textContent = t.title;
    document.getElementById("subtitle-text").textContent = t.subtitle;
    document.getElementById("create-section-title").textContent = t.createSectionTitle;
    document.getElementById("join-section-title").textContent = t.joinSectionTitle;
    document.getElementById("label-creator-name").textContent = t.labelCreatorName;
    document.getElementById("label-time-limit").textContent = t.labelTimeLimit;
    document.getElementById("label-difficulty").textContent = t.labelDifficulty;
    document.getElementById("label-join-name").textContent = t.labelJoinName;
    document.getElementById("label-join-code").textContent = t.labelJoinCode;
    document.getElementById("btn-create-text").textContent = t.btnCreate;
    document.getElementById("btn-join-text").textContent = t.btnJoin;
    document.getElementById("join-help-text").textContent = t.joinHelp;
    document.getElementById("room-section-title").textContent = t.roomSectionTitle;
    document.getElementById("room-code-label").textContent = t.roomCodeLabel;
    document.getElementById("room-link-label").textContent = t.roomLinkLabel;
    document.getElementById("room-difficulty-label").textContent = t.roomDifficultyLabel;
    document.getElementById("players-section-title").textContent = t.playersSectionTitle;
    document.getElementById("bomb-section-title").textContent = t.bombSectionTitle;
    document.getElementById("btn-submit-text").textContent = t.btnSubmit;
    document.getElementById("scoreboard-title").textContent = t.labelScoreboard;
    document.getElementById("bot-section-title").textContent = t.botSectionTitle;
    document.getElementById("bot-helper-text").textContent = t.botHelper;
    document.getElementById("add-bot-btn-text").textContent = t.addBotButton;

    const diffSelect = document.getElementById("difficulty-level");
    diffSelect.querySelector('option[value="normal"]').textContent = t.difficultyNormal;
    diffSelect.querySelector('option[value="hard"]').textContent = t.difficultyHard;
    diffSelect.querySelector('option[value="very_hard"]').textContent = t.difficultyVeryHard;
    updateRoomUI(); // dil deƒüi≈üince textleri tazele
  }

  const funSafeMessages = {
    tr: [
      name => `${name}: Bombayƒ± ≈üimdilik sakinle≈ütirdi.`,
      name => `${name}: Hesap kitap saƒülam, bomba sende deƒüil artƒ±k.`,
      name => `${name}: Doƒüru cevapla patlamadan yƒ±rttƒ±.`
    ],
    en: [
      name => `${name}: Defused it just in time.`,
      name => `${name}: Clean math, clean hands.`,
      name => `${name}: Escaped the blast this round.`
    ]
  };

  const funBoomMessages = {
    tr: [
      name => `üí• ${name} i√ßin lobby zamanƒ±.`,
      name => `üí• ${name} patladƒ±, skorlar g√ºncellendi.`,
    ],
    en: [
      name => `üí• ${name} just exploded.`,
      name => `üí• ${name} is out, scores updated.`,
    ]
  };

  function pickSafeMsg(name) {
    const list = funSafeMessages[currentLang];
    return list[Math.floor(Math.random() * list.length)](name);
  }

  function pickBoomMsg(name) {
    const list = funBoomMessages[currentLang];
    return list[Math.floor(Math.random() * list.length)](name);
  }

  function getDifficultyLabel(value) {
    const t = textMap[currentLang];
    if (value === "hard") return t.difficultyHard;
    if (value === "very_hard") return t.difficultyVeryHard;
    return t.difficultyNormal;
  }

  // --- Audio (Web Audio) ---
  let audioCtx = null;
  function getAudioCtx() {
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) audioCtx = new AC();
    }
    return audioCtx;
  }

  function playTickSound(remaining) {
    const ctx = getAudioCtx();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const baseFreq = remaining <= 5 ? 950 : 520;
    osc.type = "square";
    osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
    gain.gain.setValueAtTime(remaining <= 5 ? 0.16 : 0.06, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.08);
  }

  function playExplosionSound() {
    const ctx = getAudioCtx();
    if (!ctx) return;
    const len = ctx.sampleRate * 0.75;
    const buffer = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < len; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(900, ctx.currentTime);
    gain.gain.setValueAtTime(0.9, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.75);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);
    noise.start();

    const boomOsc = ctx.createOscillator();
    const boomGain = ctx.createGain();
    boomOsc.type = "sawtooth";
    boomOsc.frequency.setValueAtTime(70, ctx.currentTime);
    boomGain.gain.setValueAtTime(0.3, ctx.currentTime);
    boomGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.8);
    boomOsc.connect(boomGain);
    boomGain.connect(ctx.destination);
    boomOsc.start();
    boomOsc.stop(ctx.currentTime + 0.8);
  }

  // Helpers
  function randomSlug(len = 6) {
    return Math.random().toString(36).substring(2, 2 + len).toUpperCase();
  }

  function log(msg) {
    const logEl = document.getElementById("log");
    const line = document.createElement("div");
    line.className = "log-line";
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function randInt(min, max) {
    return min + Math.floor(Math.random() * (max - min + 1));
  }

  function generateNormalQuestion() {
    const patterns = [
      () => {
        const a = randInt(15, 120);
        const b = randInt(10, 90);
        return { text: `${a} + ${b} = ?`, ans: a + b };
      },
      () => {
        let a = randInt(40, 150);
        let b = randInt(10, 80);
        if (b > a) [a, b] = [b, a];
        return { text: `${a} - ${b} = ?`, ans: a - b };
      },
      () => {
        const a = randInt(6, 18);
        const b = randInt(4, 14);
        return { text: `${a} √ó ${b} = ?`, ans: a * b };
      },
      () => {
        const divisor = randInt(4, 14);
        const result = randInt(4, 16);
        const dividend = divisor * result;
        return { text: `${dividend} √∑ ${divisor} = ?`, ans: result };
      },
      () => {
        const a = randInt(10, 60);
        const b = randInt(5, 25);
        const c = randInt(2, 10);
        return { text: `${a} + ${b} √ó ${c} = ?`, ans: a + b * c };
      }
    ];
    return patterns[Math.floor(Math.random() * patterns.length)]();
  }

  function generateHardQuestion() {
    const patterns = [
      () => {
        const a = randInt(8, 20);
        const b = randInt(6, 16);
        const c = randInt(5, 25);
        return { text: `(${a} √ó ${b}) - ${c} = ?`, ans: a * b - c };
      },
      () => {
        const a = randInt(8, 18);
        const b = randInt(3, 9);
        const c = randInt(4, 10);
        return { text: `${a} √ó ${b} + ${c} = ?`, ans: a * b + c };
      },
      () => {
        const c = randInt(4, 12);
        const result = randInt(5, 18);
        const b = randInt(10, 50);
        const a = result * c + b;
        return { text: `(${a} - ${b}) √∑ ${c} = ?`, ans: result };
      },
      () => {
        const a = randInt(6, 14);
        const b = randInt(6, 14);
        const c = randInt(2, 9);
        return { text: `${a} √ó ${b} - ${c} = ?`, ans: a * b - c };
      },
      () => {
        const base = randInt(5, 11);
        const exp = 2;
        const c = randInt(10, 30);
        return { text: `${base}^${exp} + ${c} = ?`, ans: base ** exp + c };
      }
    ];
    return patterns[Math.floor(Math.random() * patterns.length)]();
  }

  function generateVeryHardQuestion() {
    const patterns = [
      () => {
        const a = randInt(8, 16);
        const b = randInt(6, 14);
        const c = randInt(3, 9);
        const d = randInt(2, 8);
        return { text: `(${a} √ó ${b}) + ${c} √ó ${d} = ?`, ans: a * b + c * d };
      },
      () => {
        const c = randInt(4, 12);
        const d = randInt(3, 9);
        const baseQuotient = randInt(6, 16);
        const left = baseQuotient * c;
        const a = randInt(10, left - 10);
        const b = left - a;
        return { text: `(${a} + ${b}) √∑ ${c} + ${d} = ?`, ans: baseQuotient + d };
      },
      () => {
        const a = randInt(7, 15);
        const b = randInt(5, 12);
        const c = randInt(3, 9);
        return { text: `${a}¬≥ - (${b} √ó ${c}) = ?`, ans: a ** 3 - b * c };
      },
      () => {
        const divisor = randInt(3, 12);
        const d = randInt(2, 8);
        const diff = divisor * randInt(4, 12);
        const a = randInt(diff + 30, diff + 120);
        const b = a - diff;
        const result = (diff * d) / divisor;
        return { text: `((${a} - ${b}) √ó ${d}) √∑ ${divisor} = ?`, ans: result };
      },
      () => {
        const a = randInt(9, 18);
        const b = randInt(4, 12);
        const c = randInt(3, 10);
        return { text: `${a}¬≤ - ${b} √ó ${c} = ?`, ans: a ** 2 - b * c };
      }
    ];
    return patterns[Math.floor(Math.random() * patterns.length)]();
  }

  function generateQuestion(difficulty = "normal") {
    if (difficulty === "hard") return generateHardQuestion();
    if (difficulty === "very_hard") return generateVeryHardQuestion();
    return generateNormalQuestion();
  }

  function isBotPlayer(player) {
    if (!player || !player.name) return false;
    return /^ü§ñ/.test(player.name) || /\bBOT\b/i.test(player.name);
  }

  function generateBotName() {
    const pool = ["Nova", "Delta", "Pixel", "Orion", "Flux", "Lambda", "Echo", "Karma", "Rogue", "Sigma"];
    const name = pool[(botCounter - 1) % pool.length];
    let candidate = `ü§ñ ${name}`;
    const existing = new Set(players.map(p => p.name));
    while (existing.has(candidate)) {
      botCounter += 1;
      candidate = `ü§ñ ${name} ${botCounter}`;
    }
    botCounter += 1;
    return candidate;
  }

  function resetBotScheduling() {
    if (botActionTimeout) clearTimeout(botActionTimeout);
    botActionTimeout = null;
    lastBotHandledKey = null;
  }

  function saveLocalState() {
    if (!currentGame || !currentPlayer) return;
    try {
      localStorage.setItem(
        LS_KEY,
        JSON.stringify({ gameSlug: currentGame.slug, playerId: currentPlayer.id })
      );
    } catch (_) {}
  }

  function clearLocalState() {
    try { localStorage.removeItem(LS_KEY); } catch (_) {}
  }

  // --- State ---
  let currentGame = null;
  let currentPlayer = null;
  let players = [];
  let isCreator = false;
  let pollInterval = null;
  let timerInterval = null;
  let lastSecondShown = null;
  let botActionTimeout = null;
  let lastBotHandledKey = null;
  let botCounter = 1;

  // DOM refs
  const setupSection = document.getElementById("setup-section");
  const gameSection = document.getElementById("game-section");
  const roomCodeEl = document.getElementById("room-code");
  const roomLinkEl = document.getElementById("room-link");
  const roomStatusText = document.getElementById("room-status-text");
  const playersList = document.getElementById("players-list");
  const statusText = document.getElementById("status-text");
  const statusActions = document.getElementById("status-actions");
  const questionTextEl = document.getElementById("question-text");
  const answerInput = document.getElementById("answer-input");
  const passTargetSelect = document.getElementById("pass-target");
  const bombEl = document.getElementById("bomb");
  const bombTimerEl = document.getElementById("bomb-timer");
  const roomDifficultyEl = document.getElementById("room-difficulty");
  const botControls = document.getElementById("bot-controls");
  const botCountInput = document.getElementById("bot-count");
  const addBotBtn = document.getElementById("add-bot-btn");
  const botHelperText = document.getElementById("bot-helper-text");

  let uiUpdatePending = false;
  function scheduleUIUpdate() {
    if (uiUpdatePending) return;
    uiUpdatePending = true;
    requestAnimationFrame(() => {
      uiUpdatePending = false;
      updateRoomUI();
    });
  }

  function updateRoomUI() {
    const t = textMap[currentLang];

    if (!currentGame) return;

    roomCodeEl.textContent = currentGame.slug;
    const link = `${window.location.origin}${window.location.pathname}?game=${currentGame.slug}`;
    roomLinkEl.href = link;
    roomLinkEl.textContent = link;
    roomDifficultyEl.textContent = getDifficultyLabel(currentGame.difficulty || "normal");

    let label = "";
    if (currentGame.status === "waiting") label = t.statusWaiting;
    else if (currentGame.status === "running") {
      const turn = players.find(p => p.id === currentGame.current_player_id);
      if (turn) {
        label = `${t.statusRunningPrefix} <strong>${turn.name}</strong>`;
      } else {
        label = t.statusTurnPreparing;
      }
    } else {
      label = t.statusFinished;
    }
    roomStatusText.textContent = label.replace(/<[^>]+>/g, "");

    // players list
    playersList.innerHTML = "";
    players.forEach(p => {
      const row = document.createElement("div");
      row.className = "player-row";

      const left = document.createElement("div");
      left.className = "player-name";
      const dot = document.createElement("div");
      dot.className = "player-dot";
      if (!p.is_alive) dot.classList.add("dead");
      left.appendChild(dot);

      const nameSpan = document.createElement("span");
      const youPrefix = currentPlayer && p.id === currentPlayer.id ? `(${t.youLabel}) ` : "";
      nameSpan.textContent = youPrefix + p.name;
      left.appendChild(nameSpan);

      const right = document.createElement("div");
      if (p.is_creator) {
        const hostTag = document.createElement("span");
        hostTag.className = "player-tag";
        hostTag.textContent = t.hostTag;
        right.appendChild(hostTag);
      }
      if (!p.is_alive) {
        const deadTag = document.createElement("span");
        deadTag.className = "player-tag";
        deadTag.textContent = t.deadTag;
        right.appendChild(deadTag);
      }
      if (isBotPlayer(p)) {
        const botTag = document.createElement("span");
        botTag.className = "player-tag";
        botTag.textContent = t.botTag;
        right.appendChild(botTag);
      }
      const turn = currentGame.current_player_id === p.id && currentGame.status === "running";
      if (turn) {
        const turnTag = document.createElement("span");
        turnTag.className = "player-tag";
        turnTag.style.borderColor = "#38bdf8";
        turnTag.style.color = "#38bdf8";
        turnTag.textContent = currentLang === "tr" ? "Sƒ±ra" : "Turn";
        right.appendChild(turnTag);
      }

      row.appendChild(left);
      row.appendChild(right);
      playersList.appendChild(row);
    });

    // banner rich html
    let bannerHTML = "";
    if (currentGame.status === "waiting") {
      bannerHTML = t.statusWaiting;
    } else if (currentGame.status === "running") {
      const turn = players.find(p => p.id === currentGame.current_player_id);
      if (turn) {
        bannerHTML = `${t.statusRunningPrefix} <strong>${turn.name}</strong>`;
      } else {
        bannerHTML = t.statusTurnPreparing;
      }
    } else {
      const loser = players.find(p => !p.is_alive);
      if (loser) bannerHTML = `<span class="status-danger">${t.logTimeout(loser.name)}</span>`;
      else bannerHTML = `<span class="status-danger">${t.statusFinished}</span>`;
    }
    statusText.innerHTML = bannerHTML;

    // question
    if (currentGame.current_question) {
      questionTextEl.textContent = currentGame.current_question;
    } else if (currentGame.status === "waiting") {
      questionTextEl.textContent = currentLang === "tr" ? "Oyun ba≈üladƒ±ktan sonra sorular burada." : "Questions will appear here once game starts.";
    } else {
      questionTextEl.textContent = currentLang === "tr" ? "Soru bekleniyor..." : "Waiting for question...";
    }

    // pass target list:
    passTargetSelect.innerHTML = "";
    const aliveOthers = players.filter(
      p => p.is_alive && currentGame && p.id !== currentGame.current_player_id
    );
    aliveOthers.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.id;
      opt.textContent = p.name;
      passTargetSelect.appendChild(opt);
    });

    // scoreboard
    const sbBody = document.getElementById("scoreboard-body");
    sbBody.innerHTML = "";
    const sorted = [...players].sort((a,b) => (b.score||0) - (a.score||0));
    sorted.forEach(p => {
      const row = document.createElement("div");
      row.className = "score-row";
      const name = document.createElement("div");
      name.textContent = p.name;
      const pts = document.createElement("div");
      pts.className = "score-points";
      const s = p.score || 0;
      pts.textContent = s > 0 ? `+${s}` : `${s}`;
      row.appendChild(name);
      row.appendChild(pts);
      sbBody.appendChild(row);
    });

    if (botControls) {
      const canControlBots = isCreator;
      const locked = currentGame.status === "running";
      botControls.style.display = canControlBots ? "block" : "none";
      botCountInput.disabled = !canControlBots || locked;
      addBotBtn.disabled = !canControlBots || locked;
      botHelperText.textContent = locked ? t.botLocked : t.botHelper;
    }

    // buttons in banner
    statusActions.innerHTML = "";
    const tbtn = textMap[currentLang];

    if (isCreator && currentGame.status === "waiting") {
      const startBtn = document.createElement("button");
      startBtn.textContent = tbtn.btnStartGame;
      startBtn.onclick = startGame;
      statusActions.appendChild(startBtn);
    }

    if (currentGame.status === "finished" && isCreator) {
      const again = document.createElement("button");
      again.textContent = tbtn.btnPlayAgain;
      again.onclick = restartGame;
      statusActions.appendChild(again);

      const newRoom = document.createElement("button");
      newRoom.className = "secondary";
      newRoom.textContent = tbtn.btnNewRoom;
      newRoom.onclick = () => {
        clearLocalState();
        window.location.href = window.location.pathname;
      };
      statusActions.appendChild(newRoom);
    }

    maybeTriggerBotTurn();

    // answer input enable / disable
    const myTurn = currentGame.status === "running" &&
      currentGame.current_player_id === (currentPlayer && currentPlayer.id) &&
      currentPlayer && currentPlayer.is_alive;

    answerInput.disabled = !myTurn;
    passTargetSelect.disabled = !myTurn || aliveOthers.length === 0;
    document.getElementById("submit-answer-btn").disabled =
      !myTurn || aliveOthers.length === 0;

    if (!myTurn) {
      answerInput.value = "";
    }
  }

  async function fetchPlayers(gameId) {
    const { data, error } = await supabase
      .from("mb_players")
      .select("*")
      .eq("game_id", gameId)
      .order("created_at", { ascending: true });
    if (!error) {
      players = data;
      if (currentPlayer) {
        const me = players.find(p => p.id === currentPlayer.id);
        if (me) currentPlayer = me;
      }
      scheduleUIUpdate();
    }
  }

  async function fetchGameBySlug(slug) {
    const { data, error } = await supabase
      .from("mb_games")
      .select("*")
      .eq("slug", slug)
      .single();
    if (error) return null;
    return data;
  }

  async function fetchGameById(id) {
    const { data, error } = await supabase
      .from("mb_games")
      .select("*")
      .eq("id", id)
      .single();
    if (error) return null;
    return data;
  }

  async function fetchPlayerById(id) {
    const { data, error } = await supabase
      .from("mb_players")
      .select("*")
      .eq("id", id)
      .single();
    if (error) return null;
    return data;
  }

  async function pollGameState() {
    if (!currentGame) return;
    const game = await fetchGameById(currentGame.id);
    if (game) {
      currentGame = game;
      await fetchPlayers(game.id);
      scheduleUIUpdate();
    }
  }

  function startPolling() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(pollGameState, 4000);
  }

  function attachRealtime(gameId) {
    supabase
      .channel("mb-game-" + gameId)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "mb_games", filter: `id=eq.${gameId}` },
        payload => {
          if (payload.new) {
            currentGame = payload.new;
            scheduleUIUpdate();
          }
        }
      )
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "mb_players", filter: `game_id=eq.${gameId}` },
        () => {
          fetchPlayers(gameId);
        }
      )
      .subscribe();

    startPolling();
    startTimerLoop();
  }

  function startTimerLoop() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      updateTimerVisuals();
      checkTimeout();
    }, 200);
  }

  function updateTimerVisuals() {
    if (!currentGame || !currentGame.deadline_at || currentGame.status !== "running") {
      bombTimerEl.textContent = "--";
      bombEl.classList.remove("exploding");
      bombEl.classList.remove("ticking");
      bombEl.classList.remove("critical");
      bombTimerEl.classList.remove("flash");
      lastSecondShown = null;
      return;
    }

    const now = Date.now();
    const deadline = new Date(currentGame.deadline_at).getTime();
    let remaining = Math.max(0, Math.ceil((deadline - now) / 1000));

    bombTimerEl.textContent = remaining.toString();
    bombEl.classList.toggle("ticking", remaining > 0);
    bombEl.classList.toggle("critical", remaining > 0 && remaining <= 5);
    bombTimerEl.classList.toggle("flash", remaining > 0 && remaining <= 5);
    if (remaining === 0) {
      bombEl.classList.add("exploding");
    } else {
      bombEl.classList.remove("exploding");
    }

    if (remaining !== lastSecondShown && remaining > 0) {
      lastSecondShown = remaining;
      playTickSound(remaining);
    }
  }

  async function createGame() {
    const t = textMap[currentLang];
    const name = document.getElementById("creator-name").value.trim();
    const limit = Number(document.getElementById("time-limit").value);
    const difficulty = document.getElementById("difficulty-level").value;
    const errEl = document.getElementById("create-error");
    errEl.textContent = "";

    if (!name) {
      errEl.textContent = t.errorNameRequired;
      return;
    }

    const slug = randomSlug();

    const { data: game, error } = await supabase
      .from("mb_games")
      .insert({
        slug,
        status: "waiting",
        creator_name: name,
        time_limit_seconds: limit,
        difficulty
      })
      .select()
      .single();

    if (error) {
      errEl.textContent = "Oyun olu≈üturulamadƒ±: " + error.message;
      return;
    }

    const { data: player, error: pErr } = await supabase
      .from("mb_players")
      .insert({
        game_id: game.id,
        name,
        is_creator: true
      })
      .select()
      .single();

    if (pErr) {
      errEl.textContent = "Oyuncu eklenemedi: " + pErr.message;
      return;
    }

    isCreator = true;
    currentGame = game;
    currentPlayer = player;

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(t.logGameCreated(game.slug));

    saveLocalState();
    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  async function joinGameByCode() {
    const t = textMap[currentLang];
    const name = document.getElementById("join-name").value.trim();
    const code = document.getElementById("join-code").value.trim().toUpperCase();
    const errEl = document.getElementById("join-error");
    errEl.textContent = "";

    if (!name) {
      errEl.textContent = t.errorNameRequired;
      return;
    }
    if (!code) {
      errEl.textContent = t.errorCodeRequired;
      return;
    }

    const game = await fetchGameBySlug(code);
    if (!game) {
      errEl.textContent = t.errorRoomNotFound;
      return;
    }

    const { data: player, error: pErr } = await supabase
      .from("mb_players")
      .insert({
        game_id: game.id,
        name,
        is_creator: false
      })
      .select()
      .single();

    if (pErr) {
      errEl.textContent = "Oyuncu eklenemedi: " + pErr.message;
      return;
    }

    isCreator = !!player.is_creator;
    currentGame = game;
    currentPlayer = player;

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(t.logJoined(game.slug));

    saveLocalState();
    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  async function addBots() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];

    if (currentGame.status === "running") {
      log(t.botLocked);
      return;
    }

    let count = Number(botCountInput.value) || 1;
    if (count < 1) count = 1;
    if (count > 6) count = 6;
    botCountInput.value = count;

    for (let i = 0; i < count; i++) {
      const name = generateBotName();
      const { error } = await supabase
        .from("mb_players")
        .insert({ game_id: currentGame.id, name, is_creator: false })
        .select()
        .single();
      if (error) {
        log(`Bot eklenemedi: ${error.message}`);
        break;
      }
    }

    log(t.logBotsAdded(count));
    await fetchPlayers(currentGame.id);
    scheduleUIUpdate();
  }

  async function startGame() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];

    const alive = players.filter(p => p.is_alive);
    if (alive.length < 2) {
      log(currentLang === "tr" ? "En az 2 oyuncu olmalƒ±." : "At least 2 players are required.");
      return;
    }

    const first = alive[Math.floor(Math.random() * alive.length)];
    const { text, ans } = generateQuestion(currentGame.difficulty || "normal");
    const now = new Date();
    const deadline = new Date(now.getTime() + currentGame.time_limit_seconds * 1000);

    const { data, error } = await supabase
      .from("mb_games")
      .update({
        status: "running",
        started_at: now.toISOString(),
        current_player_id: first.id,
        current_question: text,
        current_answer: ans,
        deadline_at: deadline.toISOString()
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (error) {
      log("Oyun ba≈ülatƒ±lamadƒ±: " + error.message);
      return;
    }

    currentGame = data;
    log(t.logStart(first.name));
    log(t.logQuestion(text));
    scheduleUIUpdate();
  }

  async function updateScoresAfterRound(loserId) {
    if (!currentGame) return;

    const { data: curPlayers, error } = await supabase
      .from("mb_players")
      .select("*")
      .eq("game_id", currentGame.id);

    if (error || !curPlayers) return;

    for (const p of curPlayers) {
      let delta = 0;
      if (p.id === loserId) delta = -2;
      else if (p.is_alive) delta = 2;

      if (delta !== 0) {
        await supabase
          .from("mb_players")
          .update({ score: (p.score || 0) + delta })
          .eq("id", p.id);
      }
    }

    await fetchPlayers(currentGame.id);
  }

  async function handleCorrectAnswer(nextPlayerId) {
    if (!currentGame) return;
    const t = textMap[currentLang];

    const next = players.find(p => p.id === Number(nextPlayerId) && p.is_alive);
    const shooter = players.find(p => p.id === currentGame.current_player_id);

    if (!next || !shooter) return;

    const { text, ans } = generateQuestion(currentGame.difficulty || "normal");
    const now = new Date();
    const deadline = new Date(now.getTime() + currentGame.time_limit_seconds * 1000);

    const { data, error } = await supabase
      .from("mb_games")
      .update({
        current_player_id: next.id,
        current_question: text,
        current_answer: ans,
        deadline_at: deadline.toISOString()
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (!error && data) {
      currentGame = data;
      log(pickSafeMsg(shooter.name));
      log(t.logAnswerCorrect(shooter.name, next.name));
      log(t.logQuestion(text));
      scheduleUIUpdate();
    }
  }

  function maybeTriggerBotTurn() {
    if (!isCreator) return;
    if (!currentGame || currentGame.status !== "running") {
      resetBotScheduling();
      return;
    }

    const actingPlayer = players.find(
      p => p.id === currentGame.current_player_id && p.is_alive
    );
    if (!actingPlayer || !isBotPlayer(actingPlayer)) {
      resetBotScheduling();
      return;
    }

    const key = `${currentGame.id}-${currentGame.current_player_id}-${currentGame.deadline_at}`;
    if (lastBotHandledKey === key || botActionTimeout) return;
    lastBotHandledKey = key;

    const deadlineMs = currentGame.deadline_at ? new Date(currentGame.deadline_at).getTime() : 0;
    const now = Date.now();
    const baseDelay = 600 + Math.random() * 900;
    const safeDelay = deadlineMs ? Math.max(200, Math.min(baseDelay, deadlineMs - now - 900)) : baseDelay;

    botActionTimeout = setTimeout(() => botAttemptAnswer(actingPlayer), safeDelay);
  }

  async function botAttemptAnswer(botPlayer, forceCorrect = false) {
    botActionTimeout = null;
    if (!currentGame || currentGame.status !== "running") return;
    if (!botPlayer || !botPlayer.is_alive) return;
    if (currentGame.current_player_id !== botPlayer.id) return;

    const deadline = currentGame.deadline_at ? new Date(currentGame.deadline_at).getTime() : 0;
    if (deadline && Date.now() > deadline) return;

    const aliveTargets = players.filter(p => p.is_alive && p.id !== botPlayer.id);
    if (aliveTargets.length === 0) return;
    const target = aliveTargets[Math.floor(Math.random() * aliveTargets.length)];

    const knowsAnswer = forceCorrect || Math.random() < 0.9;
    const t = textMap[currentLang];
    log(t.logBotThinking(botPlayer.name));

    if (!knowsAnswer) {
      log(t.logBotWrong(botPlayer.name));
      const retryDelay = deadline ? Math.max(300, Math.min(900, deadline - Date.now() - 400)) : 700;
      if (retryDelay > 0) {
        botActionTimeout = setTimeout(() => botAttemptAnswer(botPlayer, true), retryDelay);
      }
      return;
    }

    await handleCorrectAnswer(target.id);
  }

  async function submitAnswer() {
    if (!currentGame || !currentPlayer) return;
    if (currentGame.status !== "running") return;
    if (currentGame.current_player_id !== currentPlayer.id) return;

    getAudioCtx(); // kullanƒ±cƒ± etkile≈üimi ile a√ß

    const raw = answerInput.value.trim();
    if (!raw) return;
    const guess = Number(raw);
    if (!Number.isFinite(guess)) return;

    const now = Date.now();
    const deadline = currentGame.deadline_at ? new Date(currentGame.deadline_at).getTime() : 0;
    if (deadline && now > deadline) {
      // s√ºre zaten bitmi≈ü ise; timeout fonksiyonu halleder
      return;
    }

    const correct = guess === currentGame.current_answer;
    if (!correct) {
      log(textMap[currentLang].logAnswerWrong(currentPlayer.name));
      return;
    }

    const targetId = passTargetSelect.value;
    if (!targetId) return;

    answerInput.value = "";
    await handleCorrectAnswer(targetId);
  }

  async function checkTimeout() {
    if (!currentGame || currentGame.status !== "running") return;
    if (!currentGame.deadline_at) return;

    const now = Date.now();
    const deadline = new Date(currentGame.deadline_at).getTime();
    if (now <= deadline) return;

    const t = textMap[currentLang];

    const loser = players.find(p => p.id === currentGame.current_player_id);
    if (!loser) return;

    const { data, error } = await supabase
      .from("mb_games")
      .update({
        status: "finished",
        ended_at: new Date().toISOString()
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (error) return;

    currentGame = data;

    await supabase
      .from("mb_players")
      .update({ is_alive: false })
      .eq("id", loser.id);

    log(pickBoomMsg(loser.name));
    log(t.logTimeout(loser.name));
    playExplosionSound();

    await updateScoresAfterRound(loser.id);
    scheduleUIUpdate();
  }

  async function restartGame() {
    if (!currentGame || !isCreator) return;
    const t = textMap[currentLang];

    // t√ºm oyuncularƒ± tekrar hayata d√∂nd√ºr
    await supabase
      .from("mb_players")
      .update({ is_alive: true })
      .eq("game_id", currentGame.id);

    const { data, error } = await supabase
      .from("mb_games")
      .update({
        status: "waiting",
        current_player_id: null,
        current_question: null,
        current_answer: null,
        started_at: null,
        ended_at: null,
        deadline_at: null
      })
      .eq("id", currentGame.id)
      .select()
      .single();

    if (error) {
      log("Oyun resetlenemedi: " + error.message);
      return;
    }

    currentGame = data;
    log(t.logReset);
    await fetchPlayers(currentGame.id);
    scheduleUIUpdate();
  }

  async function autoRejoinIfPossible() {
    const params = new URLSearchParams(window.location.search);
    const gameSlugParam = params.get("game");
    if (gameSlugParam) {
      document.getElementById("join-code").value = gameSlugParam.toUpperCase();
    }

    let saved = null;
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (raw) saved = JSON.parse(raw);
    } catch (_) {}

    if (!saved?.gameSlug || !saved?.playerId) return;

    const game = await fetchGameBySlug(saved.gameSlug);
    if (!game || game.status === "finished") {
      clearLocalState();
      return;
    }

    const player = await fetchPlayerById(saved.playerId);
    if (!player) {
      clearLocalState();
      return;
    }

    currentGame = game;
    currentPlayer = player;
    isCreator = !!player.is_creator;

    setupSection.style.display = "none";
    gameSection.style.display = "block";
    log(textMap[currentLang].logJoined(game.slug));

    scheduleUIUpdate();
    attachRealtime(game.id);
    await fetchPlayers(game.id);
  }

  // Events
  document.getElementById("create-game-btn").onclick = createGame;
  document.getElementById("join-game-btn").onclick = joinGameByCode;
  document.getElementById("submit-answer-btn").onclick = submitAnswer;
  addBotBtn.onclick = addBots;
  answerInput.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      submitAnswer();
    }
  });

  const langButtons = document.querySelectorAll(".lang-btn");
  langButtons.forEach(btn => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) btn.classList.add("active");
    btn.addEventListener("click", () => {
      currentLang = lang;
      localStorage.setItem(LS_LANG, currentLang);
      langButtons.forEach(b =>
        b.classList.toggle("active", b.dataset.lang === currentLang)
      );
      applyLanguage();
    });
  });

  // init
  applyLanguage();
  autoRejoinIfPossible();
</script>
</body>
</html>
